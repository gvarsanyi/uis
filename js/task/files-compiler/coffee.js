// Generated by CoffeeScript 1.7.1
(function() {
  var FilesCoffeeCompiler, FilesCompiler, coffee,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  coffee = require('coffee-script');

  FilesCompiler = require('../files-compiler');

  FilesCoffeeCompiler = (function(_super) {
    __extends(FilesCoffeeCompiler, _super);

    function FilesCoffeeCompiler() {
      this.wrapError = __bind(this.wrapError, this);
      this.workFile = __bind(this.workFile, this);
      return FilesCoffeeCompiler.__super__.constructor.apply(this, arguments);
    }

    FilesCoffeeCompiler.prototype.workFile = function() {
      return this.preWorkFile(arguments, (function(_this) {
        return function(source, callback) {
          var err;
          try {
            if (source.data == null) {
              throw new Error('[FilesCoffeeCompiler] Missing source: ' + source.path);
            }
            source[_this.sourceProperty] = coffee.compile(source.data, {
              bare: true
            });
          } catch (_error) {
            err = _error;
            _this.error(err, source);
          }
          return callback();
        };
      })(this));
    };

    FilesCoffeeCompiler.prototype.wrapError = function(inf, source) {
      var data, from, i, line_literal, lines, n, to, _i, _len, _ref, _ref1, _ref2, _ref3;
      data = FilesCoffeeCompiler.__super__.wrapError.apply(this, arguments);
      if (inf.constructor.name) {
        data.title = inf.constructor.name;
      }
      data.description = data.description.split('\n')[0].split(':').slice(4).join(':');
      if ((from = Number((_ref = inf.location) != null ? _ref.first_line : void 0)) && (to = Number(((_ref1 = inf.location) != null ? _ref1.last_line : void 0) || ((_ref2 = inf.location) != null ? _ref2.first_line : void 0))) && !isNaN(from) && !isNaN(to) && from >= to && from >= 0 && source.data && (lines = source.data.split('\n')).length && lines.length > to) {
        data.line = (function() {
          var _i, _ref3, _ref4, _results;
          _results = [];
          for (n = _i = _ref3 = from + 1, _ref4 = to + 1; _ref3 <= _ref4 ? _i <= _ref4 : _i >= _ref4; n = _ref3 <= _ref4 ? ++_i : --_i) {
            _results.push(n);
          }
          return _results;
        })();
        if (data.line.length === 1) {
          data.line = data.line[0];
        }
        data.lines = {
          from: Math.max(1, from - 2),
          to: Math.min(lines.length - 1, to * 1 + 4)
        };
        _ref3 = lines.slice(data.lines.from - 1, +(data.lines.to - 1) + 1 || 9e9);
        for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
          line_literal = _ref3[i];
          data.lines[i + data.lines.from] = line_literal;
        }
      }
      return data;
    };

    return FilesCoffeeCompiler;

  })(FilesCompiler);

  module.exports = FilesCoffeeCompiler;

}).call(this);
