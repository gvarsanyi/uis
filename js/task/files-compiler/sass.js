// Generated by CoffeeScript 1.7.1
(function() {
  var FilesCompiler, SassFilesCompiler, child_process, config, fs, messenger, path, sass,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  child_process = require('child_process');

  fs = require('fs');

  path = require('path');

  sass = require('node-sass');

  FilesCompiler = require('../files-compiler');

  config = require('../../config');

  messenger = require('../../messenger');

  SassFilesCompiler = (function(_super) {
    __extends(SassFilesCompiler, _super);

    function SassFilesCompiler() {
      this.workFile = __bind(this.workFile, this);
      return SassFilesCompiler.__super__.constructor.apply(this, arguments);
    }

    SassFilesCompiler.prototype.workFile = function() {
      return this.preWorkFile(arguments, (function(_this) {
        return function(source, callback) {
          var cmd, compilers, err, finish, node_sass_error, node_sass_success, stats;
          stats = {};
          compilers = 0;
          finish = function(err) {
            compilers += 1;
            if (err) {
              _this.error(err, source);
            }
            if (compilers === 2 || !source.options.rubysass) {
              if (config.singleRun) {
                return callback();
              } else {
                return _this.watch(stats.includedFiles, source, function(err) {
                  if (err) {
                    _this.error(err, source);
                  }
                  return callback();
                });
              }
            }
          };
          try {
            if (source.data == null) {
              throw new Error('[SassFilesCompiler] Missing source: ' + source.path);
            }
            if (source.options.rubysass) {
              cmd = 'sass -C -q ' + source.path;
              child_process.exec(cmd, {
                maxBuffer: 128 * 1024 * 1024
              }, function(err, stdout, stderr) {
                if (!err) {
                  source[_this.sourceProperty] = stdout;
                }
                return finish(err);
              });
            }
          } catch (_error) {
            err = _error;
            _this.error(err, source);
            callback();
          }
          try {
            if (config.singleRun && source.options.rubysass) {
              return finish();
            }
            node_sass_error = function(err) {
              var file, _ref;
              if (!((_ref = stats.includedFiles) != null ? _ref.length : void 0)) {
                file = String(err).split(':')[0];
                return fs.exists(file + '.scss', function(exists) {
                  if (exists) {
                    stats.includedFiles = [file + '.scss'];
                    return finish();
                  }
                  return fs.exists(file + '.sass', function(exists) {
                    if (exists) {
                      stats.includedFiles = [file + '.sass'];
                      return finish();
                    }
                    return fs.exists(file, function(exists) {
                      if (exists) {
                        stats.includedFiles = [file];
                      }
                      return finish();
                    });
                  });
                });
              }
            };
            node_sass_success = function(data) {
              if (!source.options.rubysass) {
                source[_this.sourceProperty] = data;
              }
              return finish();
            };
            return sass.render({
              data: source.data,
              error: node_sass_error,
              includePaths: [path.dirname(source.path) + '/'],
              stats: stats,
              success: node_sass_success
            });
          } catch (_error) {
            err = _error;
            return finish(err);
          }
        };
      })(this));
    };

    return SassFilesCompiler;

  })(FilesCompiler);

  module.exports = SassFilesCompiler;

}).call(this);
