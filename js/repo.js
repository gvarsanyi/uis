// Generated by CoffeeScript 1.7.1
(function() {
  var FilesLoader, Repo, config, gaze, glob, md5, messenger, mkdirp, path, rimraf,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  path = require('path');

  gaze = require('gaze');

  glob = require('glob');

  md5 = require('MD5');

  mkdirp = require('mkdirp');

  rimraf = require('rimraf');

  FilesLoader = require('./task/files-loader');

  config = require('./config');

  messenger = require('./messenger');

  Repo = (function() {
    function Repo() {
      this.watch = __bind(this.watch, this);
      this.work = __bind(this.work, this);
      this.shortFile = __bind(this.shortFile, this);
      this.fileUpdate = __bind(this.fileUpdate, this);
      this.checkAllTasksFinished = __bind(this.checkAllTasksFinished, this);
      this.setTmp = __bind(this.setTmp, this);
      var i, item, name, task, _i, _len, _ref, _ref1, _ref2;
      this.pathes = [];
      this.sources = {};
      this.name = this.constructor.name.replace('Repo', '').toLowerCase();
      this.setTmp();
      this.dirs = (_ref = config[this.name]) != null ? _ref.repos : void 0;
      if (!(this.dirs instanceof Array)) {
        this.dirs = [this.dirs];
      }
      _ref1 = this.dirs;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        item = _ref1[i];
        if (typeof item !== 'object') {
          this.dirs[i] = {
            repo: item
          };
        }
      }
      this.tasks = {
        filesLoader: new FilesLoader(this)
      };
      _ref2 = (typeof this.getTasks === "function" ? this.getTasks() : void 0) || {};
      for (name in _ref2) {
        task = _ref2[name];
        this.tasks[name] = task;
      }
      this.projectPath = path.resolve(process.cwd());
      this.watch();
    }

    Repo.prototype.setTmp = function() {
      var cwd, dir, err, name, tmp_dir, _i, _len, _ref;
      tmp_dir = '/tmp';
      _ref = ['TMPDIR', 'TMP', 'TEMP'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if ((dir = process.env[name]) != null) {
          tmp_dir = dir.replace(/\/$/, '');
        }
      }
      cwd = process.cwd();
      this.tmp = tmp_dir + '/uis/' + path.basename(cwd) + '/' + md5(cwd) + '/';
      this.repoTmp = this.tmp + this.name + '/';
      mkdirp(this.repoTmp);
      try {
        return rimraf.sync(this.repoTmp + '*');
      } catch (_error) {
        err = _error;
        console.error('[ERROR] Could not clear' + this.repoTmp);
        return process.exit(1);
      }
    };

    Repo.prototype.checkAllTasksFinished = function() {
      var name, task, _ref;
      if (config.singleRun) {
        _ref = this.tasks;
        for (name in _ref) {
          task = _ref[name];
          if (!task.done()) {
            return;
          }
        }
        return setTimeout(function() {
          return process.exit(0);
        }, 10);
      }
    };

    Repo.prototype.fileUpdate = function(event, file, force_reload) {
      var node;
      if (node = this.sources[file]) {
        return this.tasks.filesLoader.workFile(node, (function(_this) {
          return function(changed) {
            var _base;
            if ((changed || force_reload) && !_this.tasks.filesLoader.error()) {
              if (!node.data) {
                return messenger.note('emptied: ' + _this.shortFile(file));
              } else {
                messenger.note('updating: ' + _this.shortFile(file));
                if (typeof (_base = _this.tasks.filesLoader).followUp === "function") {
                  _base.followUp(node);
                }
                return _this.checkAllTasksFinished();
              }
            }
          };
        })(this));
      } else {
        return messenger.note('deleted: ' + this.shortFile(file));
      }
    };

    Repo.prototype.shortFile = function(file_path) {
      if (file_path.substr(0, this.projectPath.length) === this.projectPath) {
        return file_path.substr(this.projectPath.length + 1);
      }
      return file_path;
    };

    Repo.prototype.work = function(callback) {
      return this.tasks.filesLoader.work();
    };

    Repo.prototype.watch = function() {
      var dir, dir_pool, instanciate_file, update, upsert_file, watch_dir, watched;
      instanciate_file = (function(_this) {
        return function(file, options) {
          var class_ref, ext;
          ext = file.substr(file.lastIndexOf('.') + 1);
          if (class_ref = _this.extensions[ext]) {
            return new class_ref(_this, file, options);
          }
        };
      })(this);
      update = (function(_this) {
        return function(event, file) {
          return _this.fileUpdate(event, file);
        };
      })(this);
      upsert_file = (function(_this) {
        return function(node, options) {
          var inst, k, v, _results;
          if (_this.sources[node]) {
            _results = [];
            for (k in options) {
              v = options[k];
              _results.push(_this.sources[node].options[k] = v);
            }
            return _results;
          } else if (!_this.sources[node] && (inst = instanciate_file(node, options))) {
            _this.sources[node] = inst;
            return _this.pathes.push(node);
          }
        };
      })(this);
      watched = (function(_this) {
        return function(tree, options) {
          var add_nodes;
          add_nodes = function(tree) {
            var full_path, node;
            for (full_path in tree) {
              node = tree[full_path];
              if (typeof node === 'object') {
                add_nodes(node);
              } else if ('/' !== node.substr(node.length - 1)) {
                upsert_file(node, options);
              }
            }
            return null;
          };
          add_nodes(tree);
          return watch_dir();
        };
      })(this);
      dir_pool = (function() {
        var _i, _len, _ref, _results;
        _ref = this.dirs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dir = _ref[_i];
          _results.push(dir);
        }
        return _results;
      }).call(this);
      watch_dir = (function(_this) {
        return function() {
          if (!dir_pool.length) {
            _this.watchingAll = true;
            return _this.work();
          }
          dir = dir_pool.shift();
          return (function(dir) {
            var opt, options, pattern, pattern_count, pattern_done, watch, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _results;
            options = {};
            _ref = ['testOnly', 'thirdParty'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              opt = _ref[_i];
              if (dir[opt]) {
                options[opt] = dir[opt];
              }
            }
            _ref1 = ['basedir', 'deploy'];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              opt = _ref1[_j];
              if (dir[opt]) {
                options[opt] = path.resolve(dir[opt]);
              } else if (config[_this.name][opt]) {
                options[opt] = path.resolve(config[_this.name][opt]);
              }
            }
            _ref2 = ['minify', 'rubysass'];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              opt = _ref2[_k];
              if (dir[opt]) {
                options[opt] = dir[opt];
              } else if (config[_this.name][opt]) {
                options[opt] = config[_this.name][opt];
              }
            }
            if (!((_ref3 = config[_this.name].test) != null ? _ref3.files : void 0)) {
              delete config[_this.name].test;
            } else if (typeof config[_this.name].test.files !== 'object') {
              config[_this.name].test.files = [config[_this.name].test.files];
            }
            if (config.singleRun) {
              if (typeof dir.repo !== 'object') {
                dir.repo = [dir.repo];
              }
              pattern_count = dir.repo.length;
              pattern_done = 0;
              _ref4 = dir.repo;
              _results = [];
              for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                pattern = _ref4[_l];
                if (pattern[0] !== '/') {
                  pattern = process.cwd() + '/' + pattern;
                }
                _results.push(glob(pattern, function(err, files) {
                  var file, _len4, _m;
                  for (_m = 0, _len4 = files.length; _m < _len4; _m++) {
                    file = files[_m];
                    upsert_file(file, options);
                  }
                  pattern_done += 1;
                  if (pattern_count === pattern_done) {
                    return watch_dir();
                  }
                }));
              }
              return _results;
            } else {
              watch = new gaze;
              watch.on('ready', function(watcher) {
                return watched(watcher.watched(), options);
              });
              watch.on('all', update);
              return watch.add(dir.repo);
            }
          })(dir);
        };
      })(this);
      return watch_dir();
    };

    return Repo;

  })();

  module.exports = Repo;

}).call(this);
