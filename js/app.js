#!/usr/bin/env node
// Generated by CoffeeScript 1.7.1
(function() {
  var Child, child_process, config, name, output, service, stats, _i, _len, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  child_process = require('child_process');

  config = require('./config');

  stats = require('./stats');

  if ((_ref = config.output) !== 'fancy' && _ref !== 'plain') {
    config.output = 'plain';
  }

  output = require('./output/plugin/' + config.output);

  stats.init({
    css: {},
    html: {},
    js: {},
    test: {}
  }, {});

  Child = (function() {
    var cwd, ext;

    ext = __dirname.split('/').pop() === 'coffee' ? '.coffee' : '.js';

    cwd = process.cwd();

    Child.count = 0;

    Child.nodes = {};

    function Child(name, onMsg) {
      this.name = name;
      this.onMsg = onMsg;
      this.send = __bind(this.send, this);
      this.del = __bind(this.del, this);
      this.connect = __bind(this.connect, this);
      this.path = name;
      if (name !== 'service') {
        this.path = 'repo/' + name;
      }
      this.errBuffer = '';
      this.outBuffer = '';
      this.connect();
    }

    Child.prototype.connect = function() {
      if (this.node) {
        return;
      }
      Child.nodes[this.name] = this;
      Child.count += 1;
      this.node = child_process.fork(__dirname + '/' + this.path + ext, process.argv.slice(2), {
        cwd: cwd,
        silent: true
      });
      this.node.on('error', (function(_this) {
        return function(err) {
          if (_this.node) {
            console.error(_this.name + ' error', err);
          }
          return _this.del();
        };
      })(this));
      this.node.on('close', (function(_this) {
        return function(code, signal) {
          if (_this.node) {
            console.log(_this.name + ' closed', code, signal);
          }
          return _this.del();
        };
      })(this));
      this.node.on('exit', (function(_this) {
        return function(code, signal) {
          if (_this.node) {
            console.log(_this.name + ' exited', code, signal);
          }
          return _this.del();
        };
      })(this));
      this.node.on('disconnect', (function(_this) {
        return function() {
          if (_this.node) {
            console.log(_this.name + ' disconnected');
          }
          return _this.del();
        };
      })(this));
      this.node.stderr.on('data', (function(_this) {
        return function(data) {
          var msg, pos, _results;
          _this.errBuffer += data;
          _results = [];
          while ((pos = _this.errBuffer.indexOf('\n')) > -1) {
            msg = {
              repo: _this.name,
              type: 'note',
              error: true,
              msg: _this.errBuffer.substr(0, pos + 1)
            };
            output.error(msg);
            if (service && _this.name !== 'service') {
              service.send(msg);
            }
            _results.push(_this.errBuffer = _this.errBuffer.substr(pos + 1));
          }
          return _results;
        };
      })(this));
      this.node.stdout.on('data', (function(_this) {
        return function(data) {
          var msg, pos, _results;
          _this.outBuffer += data;
          _results = [];
          while ((pos = _this.outBuffer.indexOf('\n')) > -1) {
            msg = {
              repo: _this.name,
              type: 'note',
              msg: _this.outBuffer.substr(0, pos + 1)
            };
            output.log(msg);
            if (service && _this.name !== 'service') {
              service.send(msg);
            }
            _results.push(_this.outBuffer = _this.outBuffer.substr(pos + 1));
          }
          return _results;
        };
      })(this));
      if (this.onMsg != null) {
        return this.node.on('message', this.onMsg);
      }
    };

    Child.prototype.del = function() {
      var _ref1;
      if (!this.node) {
        return;
      }
      delete Child.nodes[this.name];
      Child.count -= 1;
      delete this.node;
      if (Child.count === 1 && (((_ref1 = Child.nodes.service) != null ? _ref1.node : void 0) != null)) {
        console.log('Shutting down service');
        Child.nodes.service.node.kill();
      }
      if (Child.count === 0 && (Child.onAllDone != null)) {
        return Child.onAllDone();
      }
    };

    Child.prototype.send = function(msg) {
      var err;
      if (!this.node) {
        return;
      }
      try {
        this.node.send(msg);
      } catch (_error) {
        err = _error;
        this.del();
        return;
      }
      return true;
    };

    return Child;

  })();

  if (config.service && !config.singleRun) {
    service = new Child('service', function(msg) {
      if ((msg != null ? msg.type : void 0) === 'note') {
        return output.note(msg);
      }
    });
    service.send({
      type: 'stat-init',
      data: stats.data,
      ids: stats.ids
    });
  }

  _ref1 = ['js', 'css', 'html', 'test'];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    name = _ref1[_i];
    if (config[name]) {
      new Child(name, function(msg) {
        var _j, _len1, _name, _ref2, _results;
        _ref2 = stats.incoming(msg);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          msg = _ref2[_j];
          if (service) {
            service.send(msg);
          }
          switch (msg != null ? msg.type : void 0) {
            case 'stat':
              if (stats[_name = msg.repo] == null) {
                stats[_name] = {};
              }
              stats[msg.repo][msg.task] = msg.stat;
              _results.push(output.update(msg));
              break;
            case 'note':
              _results.push(output.note(msg));
              break;
            default:
              _results.push(void 0);
          }
        }
        return _results;
      });
    }
  }

  Child.onAllDone = function() {
    return console.log('bye');
  };

}).call(this);
